
想实现：随便给我一个十进制的数字，我能自己转成二进制；

已知：
十进制转成二进制的时候，需要减去一个基准值；
64位的偏移量为 1023，指数位中可以一直为「整数」；

双精度符点的基准值为 10000000000，一个1，后面跟10个0；



最终的计算结果是：精度位 * 2^指数位，对么？


指数位，是怎么算出来的？

另：小数点到底在哪？


拿数字 300 举例：
300/2 = 150  余 0；

150/2  = 75    余 0；

75/2    = 37    余 1；

37/2    = 18     余 1；

18/2     = 9     余 0；
9/2       = 4     余 1；
4/2       = 2     余 0；
2/2       = 1      余 0；
1/2        =0      余 1；

余数反推回去 100101100 补全以后就是  00100101100；
300 转换成二进制为 00100101100，我只进行到了这一步，然后怎样计算指数值？


另一个数字 10.42 举例：

10/2  = 5  余 0；

5/2    = 2 余 1；

2/2   = 1 余 0；

1/2    = 0 余 1；

余数反推 1010，补全以后就是 00000001010；


小数部分计算：

.42 * 2 = .84    取 0；
.84 * 2 = 1.68  取 1；
.68 * 2 = 1.36  取 1；
.36 * 2 = .72    取 0；
.72 * 2  = 1.44  取 1；
.44 * 2  = .88   取 0；
.88 * 2 = 1.76 取 1；
.76  * 2 = 1.52 取 1；
.52 * 2 = 1.04  取 1；
.04 * 2 = .08  取 0；
......

小数部分在尾数的表示为 0110101110....


那这个 10.42 在二进制表示应该是 00000001010.0110101110....
这样的数值吧。
可实际结果为：
10000000010  010011010111000010100011110101110000...




还有最后一个问题：
0.1 + 0.2 === 0.3 => flase;
0.2 + 0.3 === 0.5 => true;
0.3 + 0.4 === 0.7 => true;
0.2 + 0.4 === 0.6 => false;
当然，这个问题，我还没深入研究，目前只是列出来。



在线转换页面：
http://www.binaryconvert.com/result_double.html?decimal=053


参考文档：
https://blog.csdn.net/abcdu1/article/details/75095781
https://blog.csdn.net/zhengyanan815/article/details/78550073


